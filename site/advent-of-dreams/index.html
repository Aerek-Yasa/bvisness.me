{{ template "simplearticle.html" article "advent-of-dreams" }}

{{ define "head" }}
<link rel="stylesheet" href="{{ relurl "tachyons.min.css" }}">
<style>
    :root {
        --spacing-0: 0;
        --spacing-1: .25rem;
        --spacing-2: .5rem;
        --spacing-3: 1rem;
        --spacing-4: 2rem;
        --spacing-5: 4rem;
        --spacing-6: 8rem;
        --spacing-7: 16rem;
    }

    .flex-fair {
        flex-basis: 1px;
        flex-grow: 1;
        flex-shrink: 1;
    }

    .g1 { gap: var(--spacing-1); }
    .g2 { gap: var(--spacing-2); }
    .g3 { gap: var(--spacing-3); }

    .youtube {
        width: 100%;
    }

    .twitter-tweet.twitter-tweet-rendered {
        margin: 0 !important;
    }

    .wide > * {
        width: 100%;
    }

    .footnote-container {
        position: relative;
    }

    .footnote {
        --shadow-color: #ccc;
        position: relative;
        width: 100vw;
        left: calc(50% - 50vw);
        box-shadow: inset 0 20px 16px -20px var(--shadow-color), inset 0 -20px 16px -20px var(--shadow-color);
        color: #666;
    }

    .footnote .container > p:first-child {
        margin-top: 0;
    }

    .footnote .container > p:last-child {
        margin-bottom: 0;
    }

    /* not small */
    @media screen and (min-width: 30em) {
        .flex-fair-ns {
            flex-basis: 1px;
            flex-grow: 1;
            flex-shrink: 1;
        }
        
        .wide {
            --wideness: 10rem;
            margin-left: calc(var(--wideness) * -1);
            margin-right: calc(var(--wideness) * -1);
            display: flex;
            justify-content: center;
        }

        .wide > * {
            max-width: calc(100vw - calc(2 * var(--spacing-3)));
        }
    }
</style>
{{ end }}

{{ define "youtube" }}
<div class="relative aspect-ratio--16x9">
    <iframe class="youtube aspect-ratio--object" src="https://www.youtube-nocookie.com/embed/{{ . }}" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
{{ end }}

{{/* witness the wideness! */}}

{{ define "wide-start" }}
<div class="wide flex justify-center">
    <div class="flex flex-column flex-row-ns g3">
        <div class="w-100 flex-fair-ns overflow-hidden">
{{ end }}

{{ define "wide-middle" }}
        </div>
        <div class="w-100 flex-fair-ns overflow-hidden">
{{ end }}

{{ define "wide-end" }}
        </div>
    </div>
</div>
{{ end }}

{{ define "footnote-start" }}
<div class="footnote-container dn" data-footnote="{{ . }}">
    <div class="footnote">
        <div class="container ph2 pv3">
{{ end }}

{{ define "footnote-end" }}
        </div>
    </div>
</div>
{{ end }}

{{ define "article content" }}
{{ apply markdown }}
I did a very stupid challenge this December - I did Advent of Code in Dreams.

(Video of either the crane problem or rope problem)

[Dreams](https://indreams.me/) is a PlayStation game creation platform by Media Molecule, the studio most famous for the LittleBigPlanet games. Users can create and share everything from games to animations to interactive art. It‚Äôs truly amazing what these tools can do - I mean, just look at [this](https://youtu.be/2HBBh8O1xpk) [stuff](https://twitter.com/LeorProject/status/1604128725414600711).
{{ end }}

<!-- 
<div class="wide flex justify-center mv4">
    <div class="flex flex-column flex-row-ns g3 items-center">
        <div class="w-100 flex-fair-ns overflow-hidden">
            {{ template "youtube" "2HBBh8O1xpk" }}
        </div>
        <div class="w-100 flex-fair-ns overflow-hidden">
            <blockquote class="twitter-tweet" data-dnt="true"><p lang="en" dir="ltr">Everything loads so fastüò±<a href="https://twitter.com/hashtag/MadeInDreams?src=hash&amp;ref_src=twsrc%5Etfw">#MadeInDreams</a> <a href="https://twitter.com/hashtag/DreamsPS4?src=hash&amp;ref_src=twsrc%5Etfw">#DreamsPS4</a> <a href="https://twitter.com/hashtag/DreamsPS5?src=hash&amp;ref_src=twsrc%5Etfw">#DreamsPS5</a> <a href="https://t.co/VhmInBBcAE">https://t.co/VhmInBBcAE</a> <a href="https://t.co/DMEHeLxHSo">pic.twitter.com/DMEHeLxHSo</a></p>&mdash; Yungfel aka Ethel Enjoyer üíñ (@LeorProject) <a href="https://twitter.com/LeorProject/status/1604128725414600711?ref_src=twsrc%5Etfw">December 17, 2022</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 
        </div>
    </div>
</div> -->
      

{{ apply markdown }}
Unfortunately I am no artist. But I am a programmer, and Dreams has a robust ‚Äúlogic‚Äù system designed for game scripting. When I bought Dreams a couple years ago, I discovered that this logic system is a capable visual scripting engine with a very thoughtful design, and I was quickly able to produce some fun results, culminating in my magnum opus: a toy LISP interpreter.

{{ template "youtube" "MiCbA3JuaWk" }}

This proved to me that Dreams was capable of just about anything. And as the leader of the [Handmade Network](https://handmade.network/), I‚Äôve heard a lot of discussion over the years about <a href="javascript:footnote('vp')">‚Äúvisual programming‚Äù</a>. So this year, I decided to give visual programming a serious try. And what better way to experiment with a new programming system than [Advent of Code](https://adventofcode.com/)?
{{ end }}

{{ template "footnote-start" "vp" }}
    {{ apply markdown }}
    By ‚Äúdiscussion‚Äù I mean ‚ÄúI am a Vim neckbeard who doesn‚Äôt understand why anyone would ever use a mouse‚Äù, or ‚ÄúI have only seen visual programming systems for children, therefore all visual programming systems are toys‚Äù, or ‚Äúactually Fred Brooks said that programs cannot be visualized‚Äù. Brilliant programmers all, but come on, have some imagination!
    {{ end }}
{{ template "footnote-end" }}

{{ apply markdown }}
# The results

I completed 15 of the 25 days of Advent of Code. By ‚Äúcompleted‚Äù I mean ‚Äúgot the example working‚Äù, because I didn‚Äôt have any way to copy-paste my actual puzzle input into Dreams. Also, Dreams doesn‚Äôt have lists.

In the end, Day 16 was too much - an optimization problem that requires recursion, Dijkstra‚Äôs algorithm, and N! runs to determine the optimal path. I spent three days trying to solve it and eventually had to admit defeat.

You can see videos of each solution on the calendar below. I‚Äôve highlighted my favorite results!

TODO: CALENDAR HERE

# A whirlwind tour of Dreams logic

Let me introduce you to programming in Dreams.
{{ end }}

{{ template "wide-start" . }}
    {{ apply markdown }}
    Dreams code is made up of nodes and wires, superficially similar to some other visual programming systems. However, it is very tightly designed and elegantly integrated into the game world. In this example, a Trigger Zone widget is wired to the Glow property of this lightbulb, causing it to light up whenever the player walks into the zone.
    {{ end }}
{{ template "wide-middle" . }}
    {{ apply markdown }}
    (Video of an elf running into and out of a zone, causing a lightbulb to change.)
    {{ end }}
{{ template "wide-end" . }}

{{ template "wide-start" . }}
    {{ apply markdown }}
    Widgets can be snapped onto a Microchip to make logic more organized. Microchips can have explicit input/output ports, allowing Microchips to serve as reusable units of code, sort of like functions or macros. Being on a Microchip does not affect the widgets‚Äô behavior (outside of inheriting a couple properties like power).
    {{ end }}
{{ template "wide-middle" . }}
    {{ apply markdown }}
    (Video of a more complicated logic setup, with a repeated ‚Äútoggle‚Äù chip that uses a selector.)

    (A toggle wouldn‚Äôt require more than a bare selector though?)
    {{ end }}
{{ template "wide-end" . }}

{{ template "wide-start" . }}
    {{ apply markdown }}
    Widgets have their own state, just like any other object in the world. Timers can be turned on and off, Selectors remember which port is active, and Signal Generators just do their own thing.
    {{ end }}
{{ template "wide-middle" . }}
    {{ apply markdown }}
    (Video of the nodes mentioned.)
    {{ end }}
{{ template "wide-end" . }}

{{ template "wide-start" . }}
    {{ apply markdown }}
    The only data type is decimal numbers. All wires are just decimal numbers. ‚ÄúBoolean‚Äù signals are typically communicated with the number 0 or the number 1.

    For convenience, there are several types of ‚Äúfat wires‚Äù that are just common bundles of other wires. (These are basically structs.) All the nodes in Dreams interact with fat wires in pleasant ways, such as the Calculator node working component-wise (allowing for both vector and scalar arithmetic). Each fat wire type can decay to a single number if necessary.
    {{ end }}
{{ template "wide-middle" . }}
    {{ apply markdown }}
    (Demo of wires I guess)
    {{ end }}
{{ template "wide-end" . }}

{{ apply markdown }}
There is no explicit execution flow like you might see in Unreal Blueprints <a href="javascript:footnote('exec')">(note)</a>. It‚Äôs usually best to think about Dreams logic as independent actors sending signals to each other. In practice, this is often literally true, since logic is usually attached to physical objects in the game world.
{{ end }}

{{ template "footnote-start" "exec" }}
    {{ apply markdown }}
    Execution is loosely ordered beginning-to-end according to node inputs and outputs; this is obviously necessary or math expressions might take multiple frames to ‚Äúsettle‚Äù. However, Dreams doesn‚Äôt prevent you from making cycles in your graph, and this can occasionally lead to the ‚Äúsettling‚Äù problem I just described. I address this pain point later on.
    {{ end }}
{{ template "footnote-end" }}

{{ apply markdown }}
# A story about an iterator

One piece of logic is a perfect microcosm of everything I learned from this challenge: the Iterator.

Every problem required me to iterate through a list in some way. Every problem had some number of lines of input, which I would loop through. My logic for this started off simple and messy, then became complicated and messy, then finally became simple and clean. Let‚Äôs go through those steps:

## Day 1: Simple and messy
{{ end }}

{{ template "wide-start" . }}
    {{ apply markdown }}
    My intuition for any list or sequence in Dreams is to use a Selector. It has up to 10 output ports, can step from one state to the next. Sounds like what I need! By using the selector to power other nodes, I can use this to step through a list of values. This structure worked well and I used it every day, but the challenge is stepping to the next item.

    I originally structured my logic like so: do stuff with the current values, and then send a wire back around to ‚ÄúNext Port‚Äù (TODO: name?) to continue. The problem, though, is that Next Port is never powered off - and when the signal is always high, we don‚Äôt keep stepping.

    I fixed this on Day 1 by wedging a timer onto Next Port. The logic for resetting this was annoying and fragile, but I got by.
    {{ end }}
{{ template "wide-middle" . }}
    {{ apply markdown }}
    (Picture of a selector powering a bunch of value sliders, all funneled through an output node, output logic wired back around to Next Port)
    {{ end }}
{{ template "wide-end" . }}

{{ apply markdown }}
I also had issues where I would step to the next port *before* the current port had finished processing. Dreams doesn‚Äôt have a clear notion of execution order, so when you have cycles in the graph, execution doesn‚Äôt always start where you want it to start. In this case, I wasn‚Äôt reliably processing the first item in the list.

I hacked my way through Day 1, but after sleeping on it, I had some good ideas that would help me in Day 2.

## Day 2: Complex and messy
{{ end }}

{{ template "wide-start" . }}
    {{ apply markdown }}
    My core insight for Day 2 was to have two distinct phases when iterating: *using* a value, and *stepping* to the next value. In a system with unclear execution order, it‚Äôs dangerous to process an item and step to the next item on the same frame. It‚Äôs not *exactly* a race condition, but it feels like one.

    My idea was to have a clock ticking high, low, high, low on some interval - when it‚Äôs high, use the current value, when it‚Äôs low, step to the next. I implemented this with a Signal Generator like so.

    This worked for Day 2‚Äôs relatively simple problem. I would not be so lucky on Day 3.
    {{ end }}
{{ template "wide-middle" . }}
    {{ apply markdown }}
    (Video from stream of the signal generator stepping, stepping, stepping.)

    (Screenshots of entire iterator could come from 1:18:50.)
    {{ end }}
{{ template "wide-end" . }}

{{ apply markdown }}
## Day 3: Complexer and messier
{{ end }}

{{ template "wide-start" . }}
    {{ apply markdown }}
    Day 3 introduced a new wrinkle: nested iterators.

    Suddenly my clock-based scheme started to break down. The outer iterator needed to step only when the inner one finished. Furthermore, I needed to reset the inner one when the outer one stepped. To accommodate this, I pulled the Signal Generator out of the iterator and replaced it with a Next input. When high, step, when low, use. I also made the iterator aware of the total number of items so it could output a Done signal; this was necessary for the inner iterator to tell the outer iterator to step.
    {{ end }}
{{ template "wide-middle" . }}
    {{ apply markdown }}
    (Screenshots of entire iterator around 2:21:30)
    {{ end }}
{{ template "wide-end" . }}

{{ apply markdown }}
This added a lot of complexity, and it took two solid hours of debugging to get the inner iterator to reset correctly. Functionally, though, this was an improvement. The iterator was now more ‚Äúpure‚Äù, a state machine with no internal timers, whose behavior depended entirely on the signals fed into it.

## Day 5: Execution order interlude
{{ end }}

{{ template "wide-start" . }}
    {{ apply markdown }}
    My iterator would serve me reasonably well for the next several days. The one big exception was when Day 5‚Äôs solution was plagued by heisenbugs, and were eventually ‚Äúfixed‚Äù by‚Ä¶removing a single wire.

    Basically, I had put myself in cycle hell. As mentioned, Dreams doesn‚Äôt have a clear execution order, especially when you have cycles in your graph. As my program got more complicated, and my cycles got larger, my logic became more likely to start execution ‚Äúin the middle‚Äù, yielding seemingly impossible results. At one point, I replaced one wire with a hardcoded value slider of the same value - and all my problems fixed themselves. This led to a rant.
    {{ end }}
{{ template "wide-middle" . }}
    {{ apply markdown }}
    [https://www.twitch.tv/videos/1671906389](https://www.twitch.tv/videos/1671906389)

    [https://youtu.be/-Q7v_M2aOS4?t=7685](https://youtu.be/-Q7v_M2aOS4?t=7685)
    {{ end }}
{{ template "wide-end" . }}

{{ apply markdown }}
My fix for this was to use Wireless Transmitters to send the Next signal to my iterator. Wireless Transmitters do not cause cycles in the graph, and according to someone in my Twitch chat, always incur a one-frame delay. This is good for me; it allows me to suggest an execution order. I would use this technique every day going forward, and it did reduce the number of cycle-based heisenbugs.

## Day 10: Simple and clean

I struggled through several more days with my iterator, and kept running into problems. Resetting in particular was a huge headache - I discovered that my logic would break if I fired Reset while Next was high. The internal ‚Äúmemory cell‚Äù that was storing the current iteration value also occasionally heisenbugged, storing nonsensical values. These issues regularly lost me at least an hour a day, and I was getting pretty demoralized.

The Iterator was also so complex that I could hardly understand it. At one point, Eric Wastl (the creator of Advent of Code) remarked in my chat that I needed a [logic analyzer](https://en.wikipedia.org/wiki/Logic_analyzer), like you would use with real electronics.

Sometime between Day 9 and Day 10, though, I had a horrifying realization: I had basically just reinvented the built-in Counter widget.
{{ end }}

{{ template "wide-start" . }}
    {{ apply markdown }}
    My iterator had a Total, a Next, and a Reset. The Counter has a Target Value, a Next, and a Reset. My Iterator output Done when the count reached the Total. The Counter outputs Done when the count reaches the Target Value. The only thing the Counter didn‚Äôt have was the Use/Next split.

    On Day 10, I started with a Counter and added a tiny amount of wrapper logic. In minutes, I had perfectly recreated my old Iterator with none of the bugs.
    {{ end }}
{{ template "wide-middle" . }}
    {{ apply markdown }}
    [https://youtu.be/mJE1MYBw4eY?t=623](https://youtu.be/mJE1MYBw4eY?t=623)
    {{ end }}
{{ template "wide-end" . }}

{{ apply markdown }}
I made zero modifications to this iterator for the rest of the challenge. It was perfect. And I was so annoyed with myself.

## How did this happen?

I had drifted toward the Counter design so slowly that I didn‚Äôt realize it. I started with a selector and no explicit counter, then transitioned to a clock, then added the inner counter, and then removed the clock. The Counter, though, didn‚Äôt have the Use/Next split, which is why I didn‚Äôt think to use it earlier.

In the end, there were two good ideas that I had to discover:

- Separate Use and Next into two mutually exclusive states to avoid same-frame bugs.
- Drive the logic manually instead of using an internal clock. Timers belong at the highest level of your logic, never hidden inside other widgets.

Both of these ideas apply broadly to programming in Dreams, so let‚Äôs break them down.

## Lesson 1: Make logic mutually exclusive

Tons of bugs boiled down to two nodes being active at the same time, when they shouldn‚Äôt have been. Early on, I tried to fix this ad-hoc with lots of AND gates powering specific nodes. Later on, though, I realized that grouping logic into Microchips not only helped me organize my logic, but actually fixed bugs too.
{{ end }}

{{ template "wide-start" . }}
    {{ apply markdown }}
    Putting logic in Microchips allows you to power entire chunks of your program on and off. Instead of running logic and then randomly suppressing some results, you can simply *not run the logic*. I think this actually fixes a lot of heisenbugs by ensuring that all the wires are zero on the first frame each widget is active. The more I used power in this way, the more I liked my logic and the fewer bugs I encountered. I developed a mantra: ‚Äúdon‚Äôt use an AND gate, use power instead‚Äù.
    {{ end }}
{{ template "wide-middle" . }}
    {{ apply markdown }}
    (Video of putting some logic in a Microchip? On one of the more nicely-organized days?)
    {{ end }}
{{ template "wide-end" . }}

{{ apply markdown }}
(TODO: Talking about timelines here seems to break flow)

This way of thinking is probably old news to those more experienced with Dreams, and here‚Äôs why: the Timeline node, which is used for all animation, sound, and fancy sequencing in Dreams, literally just powers nodes on and off. Someone on Mastodon [remarked to me](https://mastodon.nz/@flashmedallion/109539143131376443) that ‚Äútimelines = scripts‚Äù, and it blew my mind.

I‚Äôve never done animation. I‚Äôve never done sound design. I‚Äôve really never tried to *make a game* in Dreams; that‚Äôs not my thing. But this led to an enormous blind spot, because I never used Timelines, and therefore never understood how important power is in Dreams. Instead of chaining Selectors to get lists of more than 10 items, I could have used Timelines. Instead of using mazes of logic gates to power things on and off, I could have used Timelines (with multiple tracks). Instead of awkwardly sequencing things with Selectors and Timers, I could have used Timelines. The list goes on.

In the end, though, what matters is making major chunks of logic mutually exclusive. Whether you use Timelines or power things manually, you will benefit from isolating them in this way. Your logic will be easier to follow and you will avoid heisenbugs. It takes practice, but Dreams is well-designed, so well-structured logic actually does feel better. You‚Äôll know it when you see it.

## Lesson 2: Use timers, but keep them out of core logic

One of the most influential programming talks I‚Äôve seen is Gary Bernhardt‚Äôs [Boundaries](https://www.destroyallsoftware.com/talks/boundaries), in which he advocates for programs to be structured with a ‚Äúfunctional core‚Äù and ‚Äúimperative shell‚Äù. Keep your program‚Äôs core logic pure and functional, free of side effects, and push the messy (but necessary) imperative logic to the outside. Keep the core code free of side effects so it‚Äôs trustworthy and predictable, and your leaf code can be as messy as it wants to be.

In retrospect, that advice applies to Dreams just as much as any other programming environment. A Dreams project needs core logic and gameplay systems, but also needs delays and animations and time for physics objects to settle.

At first, I wrote my logic without timers. But this led to same-frame execution issues, and it was difficult to visualize my logic in the world. Then I put timers all over the place, but every time I put a timer inside some ‚Äúreusable‚Äù logic, it would later blow up on me. My iterator is the perfect example; first it did all the work at once (and was buggy), then I gave it an internal clock (which was buggy), and eventually it was a pure state machine (that worked reliably).

‚ÄúPurity‚Äù in Dreams logic isn‚Äôt exactly the same as ‚Äúpure functions‚Äù in programming; I don‚Äôt know if functional programmers would consider any state machine to be ‚Äúpure‚Äù. But Dreams is, at its heart, a bunch of <a href="javascript:footnote('state')">state machines talking to each other</a>. If you want something to be reusable, keep side effects out of it.
{{ end }}

{{ template "footnote-start" "state" }}
    {{ apply markdown }}
    I‚Äôve described Dreams before as ‚Äúthe best object-oriented programming system I‚Äôve ever used‚Äù, and this is why. I‚Äôm not claiming that Alan Kay‚Äôs vision is *the* vision for OOP, but I have to say, Dreams is pretty close to Alan Kay‚Äôs pseudo-biological, simulational description of OOP. It‚Äôs the ‚Äúactor model‚Äù writ large. It‚Äôs a concurrent, stateful, message-passing system.
    {{ end }}
{{ template "footnote-end" }}

{{ apply markdown }}
# Final thoughts

I‚Äôm really glad I did this challenge. My overall impressions of Dreams are still very positive. I‚Äôm genuinely delighted by how easy it is to kit-bash beautiful scenes together. I‚Äôm amazed by the quality and variety of material on the Dreamiverse. And I still think the logic system is brilliant.

Here‚Äôs what I like about programming in Dreams: it‚Äôs very *tangible*. And not because the code sprawls across my screen, but because it‚Äôs associated with the data it manipulates in a very real way. It‚Äôs *embodied*. There is really no boundary between the code and the world, and this allows for some wonderful workflows. For example, there is no boundary between programming and debugging - if something is acting weird, you can simply pause time, open the logic, and probe widgets and wires to see what state they‚Äôre in. Tweak the logic on the fly and resume again. It‚Äôs blissfully iterative and doesn‚Äôt require you to learn any additional tools, e.g. a time-travel debugger or a [Whitebox](https://whitebox.systems/). This is exactly how scripting should be.

Plus, every feature of Dreams is just so tightly designed. It‚Äôs one of the most thoughtful systems I‚Äôve ever used. The logic system can be simple because the rest of the engine is so carefully designed. It‚Äôs an incredibly coherent experience.

But obviously I struggled to do things that would be simple in a ‚Äúreal‚Äù programming environment. I put together a [spreadsheet](https://docs.google.com/spreadsheets/d/1OxQt5dfEQDIFmq0UrSU165OSiUTbr-DVdft1_naV9ms/edit?usp=sharing) tracking my times in Dreams vs. my times in JavaScript, and I was generally about 15x faster in JS. Even if you account for the time spent just thinking about the problem, and the time spent fixing bugs instead of ‚Äúreally programming‚Äù, this is still a staggering difference. I don‚Äôt think anything would ever close that gap.

On the other hand, I was able to go from a working implementation to a great visualization in *minutes*. The connection between Dreams logic and Dreams objects is so seamless that it‚Äôs trivial to visualize your program in pleasant ways. And this is the whole pitch of Dreams; it is working as intended.

In an ideal world, I think I would like to write my own nodes. Instead of making my state machines with a bunch of wires and logic gates (faux electronics), I‚Äôd like to actually write them in a more powerful language. Then I could tie them together with Dreams‚Äôs lovely scripting system and game engine. I legitimately think that this could be an *incredibly* powerful way to program.

# Thanks

Obviously a huge thanks to Media Molecule for dedicating the last 15 years to this weird, wonderful system. It‚Äôs a miracle that Dreams exists at all, and it‚Äôs all because of the LittleBigPlanet series, the studio‚Äôs technical prowess, and their incredible dedication to user-created content.

Thanks to various members of the Dreams community for hanging out in my stream, and a particular thanks to [TAPgiles](https://tapgiles.com/) for his Dreams documentation and tutorials.

Thanks to the Handmade community for the years of discussion about visual programming, in particular [d7](https://gist.github.com/d7samurai) for his imagination and relentless dissatisfaction with the status quo.

And thank you for reading üôÇ
{{ end }}

<script>
    function footnote(name) {
        const fn = document.querySelector(`[data-footnote="${name}"]`);
        fn.classList.toggle('dn');
    }
</script>

{{ end }}
