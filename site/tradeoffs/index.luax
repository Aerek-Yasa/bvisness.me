local article = require("articles")["tradeoffs"]
require("simplearticle")
require("images")

bhp.render(<SimpleArticle article={ article }>
    <p>
        Programmers love to say things like "it all depends" or "it's always a tradeoff". This makes them sound very wise, but it's usually a cop-out.
    </p>

    <h2>Your choices need to be mutually exclusive.</h2>

    <p>
        Let's look at a fun example from a Content Creator:
    </p>

    <Picture
        src={ relpath("triangle.png") }
        alt="A tradeoff triangle with three corners: Performance, Velocity, and Adaptability"
    />

    <p>
        I'll let my friend simp break this down:
    </p>

    <Picture
        src={ relpath("simp1.png") }
        scale={ 2 }
        alt="Discord message: It's intended to be a \"tradeoff triangle\". If adaptability is \"how quickly you can change to new requirements\" and velocity is \"how fast you can add new features\" these seem like obviously not mutually exclusive nor even really a tradeoff. They're practically the same thing."
    />
    <Picture
        src={ relpath("simp2.png") }
        scale={ 2 }
        alt="I think you could say pretty decently that there's a tradeoff with genericism and specificity wrt performance. But the idea that if I get more adaptable I lose velocity is especially nonsensical."
    />

    <p>
        I'm not sure anyone would take this seriously in the first place, but since it's so extreme, it's a nice place to start. As simp says, "velocity" and "adaptability" are basically the same thing, so they are clearly not a tradeoff. The performance vs. velocity/adaptability tradeoff is more understandable, since quickly-written code often has poor performance and highly-optimized code can be highly specialized - but even these aren't mutually exclusive.
    </p>

    <p>
        At my last company, we had a backend codebase that was massively overarchitected. Everything was designed to use an "event bus" that could seamlessly switch between synchronous and asynchronous execution of "commands", whose "handlers" were all defined through a maze of dependency injection configured with yaml files. Keep in mind, a "synchronous command" is for all intents and purposes a function call - the "command" is the arguments and the "handler" is the body. But this "event bus" added multiple layers of indirection that made it impossible for us to follow control flow. The asynchronous commands were even worse, and every so often they would basically forkbomb us by spawning copies of themselves.
    </p>

    <p>
        This system was <strong>bad on all three metrics.</strong> It had terrible performance. It was a nightmare to adapt to new requirements. And it was impossible for us to work with because we couldn't even debug anything.
    </p>

    <p>
        But it's all tradeoffs, you know. It all depends. There's costs and benefits to everything. I am very wise.
    </p>

    <h2>The code can just suck.</h2>

    <p>
        For "tradeoffs" to mean anything, you also have to achieve the best version of each option. This usually doesn't happen. You can talk about "tradeoffs" between architectures, but "tradeoffs" don't matter when you end up writing code like this:
    </p>
</SimpleArticle>)
